.386
.MODEL FLAT, STDCALL

;**************************************
							; прототипы внешних функций (процедур) описываются директивой EXTERN, 
							; после знака @ указывается общая длина передаваемых параметров,
							; после двоеточия указывается тип внешнего объекта – процедура
EXTERN  GetStdHandle@4: PROC
EXTERN  WriteConsoleA@20: PROC
EXTERN  CharToOemA@8: PROC
EXTERN  ReadConsoleA@20: PROC
EXTERN  ExitProcess@4: PROC	; функция выхода из программы
EXTERN  lstrlenA@4: PROC	; функция определения длины строки
EXTERN  wsprintfA: PROC		; т.к. число параметров функции не фиксировано,
							; используется соглашение, согласно которому очищает стек 
							; вызывающая процедура

;**************************************
.DATA; сегмент данных
STRN DB "Enter first number: ",13,10,0	; выводимая строка, в конце до-бавлены
										; управляющие символы: 13 – возврат каретки, 10 – переход на новую 
										; строку, 0 – конец строки; с использованием директивы DB 
										; резервируется массив байтов
strn2 DB "Enter second number: ",13,10,0
DIN DD ?			; дескриптор ввода; директива DD резервирует память объемом
					; 32 бита (4 байта), знак «?» используется для неинициализированных данных
DOUT DD ?			; дескриптор вывода
BUF  DB 200 dup (?)	; буфер для вводимых/выводимых строк длиной 200 бай-тов
LENS DD ?			; переменная для количества выведенных символов
					;переменные для хранения чисел
numa DD ?
numb DD ?
numc DD ?
					;переменные для хранение информации о знаке
sig1 DD ?
sig2 DD ?

;**************************************
.CODE; сегмент кода 
MAIN PROC			; метка точки входа (метка должна завершаться двоеточием)

;**************************************
; перекодируем строку STRN

MOV  EAX, OFFSET STRN	; командой MOV  значение второго операнда 
						; перемещается в первый, OFFSET – операция, возвращающая адрес
PUSH EAX				; параметры функции помещаются в стек командой PUSH
PUSH EAX
CALL CharToOemA@8		; вызов функции

;**************************************
; перекодируем строку strn2

MOV EAX, OFFSET strn2
PUSH EAX
PUSH EAX
CALL CharToOemA@8

;**************************************
; получим дескриптор ввода 

PUSH -10
CALL GetStdHandle@4
MOV DIN, EAX 		; переместить результат из регистра EAX 
					; в ячейку памяти с именем DIN

;**************************************
; получим дескриптор вывода

PUSH -11
CALL GetStdHandle@4
MOV DOUT, EAX		; переместить результат из регистра EAX 
					; в ячейку памяти с именем DOUT

;**************************************
; определим длину строки STRN

enter1:
PUSH OFFSET STRN	; в стек помещается адрес строки
CALL lstrlenA@4		; длина в EAX

					; вызов функции WriteConsoleA для вывода строки STRN
PUSH 0				; в стек помещается 5-й параметр
PUSH OFFSET LENS	; 4-й параметр
PUSH EAX			; 3-й параметр
PUSH OFFSET STRN	; 2-й параметр
PUSH DOUT			; 1-й параметр
CALL WriteConsoleA@20

;**************************************
; ввод строки

PUSH 0					; в стек помещается 5-й параметр
PUSH OFFSET LENS		; 4-й параметр
PUSH 200				; 3-й параметр
PUSH OFFSET BUF			; 2-й параметр
PUSH DIN				; 1-й параметр
CALL ReadConsoleA@20	; обратите внимание: LENS больше числа введенных
						; символов на два, дополнительно введенные символы: 13 – возврат карет-ки и 
						; 10 – переход на новую строку

;**************************************
; обработка первой строки

mov sig1, 0;
MOV ESI, OFFSET BUF		; начало строки хранится в переменной BUF
mov BL, [esi]			; помещаем первый элемент строки в регистр BL 
cmp bl, '-'				; сравниваем значение регистра BL с кодом символа -
jne contin1				; если не равны переходим на метку contin1
inc esi					; если равны увеличиваем esi на единицу 
sub lens,1				; уменьшаем длину строки на 1
inc sig1				; увеличиваем sig на 1 
contin1:
sub lens, 2
MOV DI,10
MOV ECX, LENS			; счетчик цикла (строка имеет длину LENS)
XOR EBX, EBX			; обнулить регистр EBX командой XOR, 
						; выполняющей побитно операцию «исключающее или»
XOR EAX, EAX			; обнулить регистр EAX
CONVERT1: 				; метка начала тела цикла
	MOV BL, [ESI]		; поместить символ из введенной строки в регистр 
						; BL, используя косвенную адресацию
	cmp BL, '9'			; если значение регистра BL больше кода цифры 9
	ja enter1			; то переходим на метку enter1 
	cmp BL, '0'			; если значение регистра BL меньше кода цифры 9
	jb enter1			; то переходим на метку enter1 
	SUB BL, '0'			; вычесть из введенного символа код нуля
	MUL DI				; умножить значение EAX на 10, результат – в EAX
	ADD EAX, EBX		; добавить к полученному в AX числу новую цифру
	INC ESI				; перейти на следующий символ строки
LOOP CONVERT1			; перейти на следующую итерацию цикла
MOV numa, eax			; помещаем значение регистра eax в ячейку памяти numa

;**************************************
; вывод строки strn2

enter2:
PUSH OFFSET strn2		; в стек помещается адрес строки
CALL lstrlenA@4			; длина в EAX
						; вызов функции WriteConsoleA для вывода строки strn2
PUSH 0					; в стек помещается 5-й параметр
PUSH OFFSET LENS		; 4-й параметр
PUSH EAX				; 3-й параметр
PUSH OFFSET strn2		; 2-й параметр
PUSH DOUT				; 1-й параметр
CALL WriteConsoleA@20

;**************************************
; ввод строки

PUSH 0					; в стек помещается 5-й параметр
PUSH OFFSET LENS		; 4-й параметр
PUSH 200				; 3-й параметр
PUSH OFFSET BUF			; 2-й параметр
PUSH DIN				; 1-й параметр
CALL ReadConsoleA@20	; обратите внимание: LENS больше числа введенных
						; символов на два, дополнительно введенные символы: 13 – возврат карет-ки и 
						; 10 – переход на новую строку

;**************************************
; обработка второй строки

mov sig2,0
MOV ESI, OFFSET BUF		; начало строки хранится в переменной BUF
mov BL, [esi]
cmp bl, '-'
jne contin2
inc esi
sub lens,1
inc sig2
contin2:
sub lens, 2
MOV DI,10
MOV ECX, LENS			; счетчик цикла (строка имеет длину LENS)
XOR EBX, EBX			; обнулить регистр EBX командой XOR, 
						; выполняющей побитно операцию «исключающее или»
XOR EAX, EAX			; обнулить регистр EAX
CONVERT2: 				; метка начала тела цикла
	MOV BL, [ESI]		; поместить символ из введенной строки в регистр 
						; BL, используя косвенную адресацию
	cmp BL, '9'
	ja enter2
	cmp BL, '0'
	jb enter2
	SUB BL, '0'			; вычесть из введенного символа код нуля
	MUL DI				; умножить значение EAX на 10, результат – в EAX
	ADD EAX, EBX		; добавить к полученному в EAX числу новую цифру
	INC ESI				; перейти на следующий символ строки
LOOP CONVERT2			; перейти на следующую итерацию цикла
MOV numb, eax

;**************************************
; умножение чисел

mov eax, numa	; помещаем значение из ячейки памяти numa в регистр eax
mov ebx, numb	; помещаем значение из ячейки памяти numb в регистр ebx
mul ebx			; умножаем значение регистра eax на значение ebx, результат за-писывается в eax 
mov numc, eax	; помещаем значение из регитсра eax в ячейку памяти numc

;**************************************
; преобразование результата

xor edi, edi		; обнуляем региcтр edi
mov ecx, 16			; помещаем в регистр ecx 16
beg:
cmp eax, ecx		; если число меньше 16, то переходим на метку c1
jb c1
	div ecx			; делим число на 16
	add edx, '0'	; прибавляем код символа 0
	cmp edx, '9'	; если код получившегося символа меньше или равен кода '9', то переходим на метку с2
	jbe c2
	add edx, 7		; прибавляем 7 для получения буквы
	c2:
	push edx		; помещаем символ в стек
	add edi, 1		; увеличиваем счетчик на 1
	xor edx, edx	; обнуляем edx
jmp beg				; переходим на метку beg
c1:
add eax, '0'		; прибавляем код символа 0
cmp eax, '9'		; если код получившегося символа меньше или равен кода '9', то переходим на метку с3
jbe c3
add eax, 7			; прибавляем 7 для получения буквы
c3:
push eax			; помещаем символ в стек
add edi, 1			; увеличиваем счетчик на 1
mov ecx, edi		; помещаем количество символов в регистр ecx 
mov esi, offset buf	; передаем начало строки в регистр ESI
mov ebx,sig1
mov edx,sig2
add ebx,edx
cmp ebx,1		; если количество минусов не равно 1, то переходим на метку convert3
jne convert3
push '-'		; помещаем в стек знак '-'
inc ecx			; увеличиваем счетчик цикла на 1
convert3:
pop[esi]		; удаляем символ из стека в строку
inc esi
loop convert3
push 'H'		; помещаем в стек символ 'H'
pop[esi]		; удаляем символ 'H' в строку

;**************************************
; вывод полученной строки

PUSH OFFSET BUF
CALL lstrlenA@4
PUSH 0
PUSH OFFSET LENS
PUSH eax		; длина выводимой строки
PUSH OFFSET BUF
PUSH DOUT
CALL WriteConsoleA@20

;**************************************
; выход из программы 

PUSH 0			; параметр: код выхода
CALL ExitProcess@4
MAIN ENDP
End MAIN
